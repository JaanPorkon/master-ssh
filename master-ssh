#!/usr/bin/env python

import paramiko
import requests
import argparse
import sys
import time
import threading
import ConfigParser
import os

class MasterSSH:

	connectionPool = {}
	selectedServers = []
	credentials = []
	config = None

	commandPool = []

	def __init__(self):

		configPath = os.path.realpath("/usr/local/bin/master-ssh").split('/')
		configPath.pop()

		self.config = ConfigParser.ConfigParser()
		self.config.read("/".join(configPath) + "/" + "master-ssh.conf")

		parser = argparse.ArgumentParser()
		parser.add_argument('--cred-url', dest='cred_url', default=None, help='URL that points to credentials data')
		parser.add_argument('--cred-file', dest='cred_file', default=None, help='Path to your credentials file')
		parser.add_argument('--servers', dest='servers', default=None, help='A comma separated list of server hostnames')

		args = parser.parse_args()

		credSourceType = None
		credSourcePath = None

		if args.cred_file != None:
			credSourcePath = args.cred_file
			credSourceType = 'file'
			
		if args.cred_url != None:
			credSourcePath = args.cred_url
			credSourceType = 'url'

		if args.servers != None:
			self.selectedServers = args.servers.strip().split(',')

		if credSourcePath == None:
			print "You need to specify a credentials path [--cred-url, --cred-file]"
			sys.exit(1)

		if credSourceType == 'file':
			with open(credSourcePath, 'r') as f:
				for line in f.readlines():
					data = line.strip().split(',')

					self.credentials.append({
						'name': data[0],
						'host': data[1],
						'username': data[2],
						'password': data[3]
					})

		if credSourceType == 'url':
			response = requests.get(credSourcePath)

			for line in response.text.strip().split('\n'):
				data = line.split(',')

				self.credentials.append({
					'name': data[0],
					'host': data[1],
					'username': data[2],
					'password': data[3]
				})

	def createConnections(self):	

		threadPool = {}
		threadPos = 1	
		useSelectedServers = False	

		if len(self.selectedServers) > 0:
			useSelectedServers = True			

		for cred in self.credentials:
			if useSelectedServers:
				if cred['name'] in self.selectedServers:
					threadPool[threadPos] = threading.Thread(target=self.connect, args=(cred['name'], cred['host'], cred['username'], cred['password'],))
					threadPool[threadPos].daemon = True
					threadPool[threadPos].start()
					threadPos += 1
			else:
				threadPool[threadPos] = threading.Thread(target=self.connect, args=(cred['name'], cred['host'], cred['username'], cred['password'],))
				threadPool[threadPos].daemon = True
				threadPool[threadPos].start()
				threadPos += 1

			
		for i in range(1, threadPos):
			threadPool[i].join()

			

	def connect(self, name, host, username, password):

		tries = 1
		maxTries = int(self.config.get('connection', 'max_retries'))
		delay = float(self.config.get('connection', 'delay'))

		while True:

			if tries == maxTries:
				self.printError("Unable to connect to: " + name)
				break

			try:
				self.connectionPool[name] = paramiko.SSHClient()
				self.connectionPool[name].set_missing_host_key_policy(paramiko.AutoAddPolicy()) 
				self.connectionPool[name].connect(host, username=username, password=password)

				connected = True
			except:
				self.printError("Failed to connect to: " + name + "... retrying (" + str(tries) + "/" + str(maxTries) + ")")
				connected = False
				tries += 1
				time.sleep(delay)

			if connected:
				self.printSuccess("Successfully connected to: " + name)
				break


	def closeConnections(self):

		threadPool = {}
		threadPos = 1	

		for name in self.connectionPool:	
			threadPool[threadPos] = threading.Thread(target=self.exit, args=(name,))
			threadPool[threadPos].daemon = True
			threadPool[threadPos].start()
			threadPos += 1
							
		for i in range(1, threadPos):
			threadPool[i].join()	

	def exit(self, name):
			
			try:
				self.connectionPool[name].exec_command('exit')
				self.connectionPool[name].close()
			except Exception, e:
				self.printError(str(e))

			self.printAction(name, "disconnected...")

	def listen(self):
		
		while True:

			cmd = raw_input('\nmaster-ssh$ ').strip()

			if cmd == "exit":
				self.closeConnections()
				break
			else:

				if cmd.startswith('#'):

					"""
					INTERNAL COMMANDS
					"""

					if cmd == "#help" or cmd == "#":

						print "Welcome to master-ssh!"
						print "Made by Jaan Porkon <jaantrill[at]gmail.com>"
						print "https://github.com/JaanPorkon/master-ssh"
						print ""
						print "Example syntax:"
						print "#[command]"
						print ""
						print "Example command:"
						print "#help"
						print ""
						print "Below you can find available commands that you can use:"
						print ""
						print "help                                   - Displays this message"
						print "list-connections                       - Lists the state of all connections"
						print "disconnect:[hostname,hostname2,...]    - Disconnects a specific host and removes it from the pool"
						print "                                       - Example:"
						print "                                         #disconnect:host1"
						print "                                       - or multiple servers:"
						print "                                         #disconnect:host2,host3"
						print "ignore:[hostname,hostname2] [command]  - Ignores servers that are listed"

					elif cmd == "#list-connections":
						
						for name, con in self.connectionPool.iteritems():

							isAlive = con.get_transport().is_active()

							if isAlive:
								self.printAction(name, "connection active")
							else:
								self.printServerError(name, "is disconnected")

					elif cmd.startswith('#disconnect'):

						servers = cmd.strip().split(':')[-1]

						for server in servers.split(','):
							if server in self.connectionPool:							
								connection = self.connectionPool[server]

								try:
									if connection.get_transport().is_active():
										connection.exec_command('exit')
										connection.close()
										self.connectionPool.pop(server)

										self.printSuccess(server + " successfully disconnected!")
									else:
										self.connectionPool.pop(server)
								except Exception, e:
									self.printError('Unable to disconnect: ' + server + ' (' + str(e) + ')')

							else:
								self.printError(server + " does not exist!")


						if len(self.connectionPool) == 0:
							self.printMessage("Connection pool is empty, closing the program..")
							sys.exit(0)

					else:

						"""
						SERVER COMMANDS
						"""

						useIgnoreList = False
						serverListStart = 1

						findSpace = cmd.find(' ')
						command = cmd[(findSpace + 1):len(cmd)].strip()

						if cmd.startswith("#ignore:"):
							serverListStart = 8
							useIgnoreList = True

						server = cmd[serverListStart:findSpace].strip()

						if useIgnoreList:

							ignoreList = server.strip().split(',')

							threadPool = {}
							threadPos = 1	

							for name,con in self.connectionPool.iteritems():							

								if name not in ignoreList:
									threadPool[threadPos] = threading.Thread(target=self.execute, args=(command, name, con,))
									threadPool[threadPos].daemon = True
									threadPool[threadPos].start()
									threadPos += 1
									
							for i in range(1, threadPos):
								threadPool[i].join()

							ignoreList = []

						else:
						
							if "," in server:

								threadPool = {}
								threadPos = 1

								for server in server.split(','):

									if server not in self.connectionPool:
										self.printError(server + " does not exist!")
									else:
										con = self.connectionPool[server]

										threadPool[threadPos] = threading.Thread(target=self.execute, args=(command, server, con,))
										threadPool[threadPos].daemon = True
										threadPool[threadPos].start()
										threadPos += 1
									
								for i in range(1, threadPos):
									threadPool[i].join()

							else:

								if server not in self.connectionPool:
									self.printError(server + " does not exist!")
								else:
									stdin, stdout, stderr = self.connectionPool[server].exec_command(command)

									error = ""

									for line in stderr:
										error += "\n" + line

									self.printServerError(server, error.strip())

									response = ""

									for line in stdout:
										response += line

									self.printServerAction(server, response.strip())


				else:
					threadPool = {}
					threadPos = 1	

					for name,con in self.connectionPool.iteritems():							

						threadPool[threadPos] = threading.Thread(target=self.execute, args=(cmd, name, con,))
						threadPool[threadPos].daemon = True
						threadPool[threadPos].start()
						threadPos += 1
							
					for i in range(1, threadPos):
						threadPool[i].join()
							
						

	def execute(self, cmd, name, con):
		stdin, stdout, stderr = con.exec_command(cmd)

		error = ""

		for line in stderr:
			error += "\n" + line

		self.printServerError(name, error.strip())

		response = ""

		for line in stdout:
			response += line

		self.printServerAction(name, response.strip())

	"""
	Helper methods
	"""

	def printMessage(self, message):
		print message

	def printAction(self, server, message):
		print '\033[92m\033[1m\033[4m[' + server + ']\033[0m: ' + message

	def printServerAction(self, server, message):
		print '\033[92m\033[1m\033[4m[' + server + ']\033[0m:\n' + message

	def printSuccess(self, message):
		print "\033[92m" + message + '\033[0m'

	def printError(self, message):
		if message != "":
			print 'master-ssh: \033[91m' + message + '\033[0m'

	def printServerError(self, server, message):
		if message != "":
			print '\033[92m\033[1m\033[4m[' + server + ']\033[0m: \033[91m' + message + '\033[0m'


m = MasterSSH()
m.createConnections()
m.listen()

print "SSH sessions ended, closing..."
sys.exit(0)
