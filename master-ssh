#!/usr/bin/env python

import paramiko
import requests
import argparse
import sys
import time
import threading
import ConfigParser
import os

class MasterSSH:

	connectionPool = {}
	credentials = []
	config = None

	commandPool = []

	def __init__(self):

		configPath = os.path.realpath("/usr/local/bin/master-ssh").split('/')
		configPath.pop()

		self.config = ConfigParser.ConfigParser()
		self.config.read("/".join(configPath) + "/" + "master-ssh.conf")

		parser = argparse.ArgumentParser()
		parser.add_argument('--cred-url', dest='cred_url', default=None, help='URL that points to credentials data')
		parser.add_argument('--cred-file', dest='cred_file', default=None, help='Path to your credentials file')

		args = parser.parse_args()

		credSourceType = None
		credSourcePath = None

		if args.cred_file != None:
			credSourcePath = args.cred_url
			credSourceType = 'file'
			
		if args.cred_url != None:
			credSourcePath = args.cred_url
			credSourceType = 'url'

		if credSourcePath == None:
			print "You need to specify a credentials path [--cred-url, --cred-path]"
			sys.exit(1)

		if credSourceType == 'file':
			with open(credSourcePath, 'r') as f:
				for line in r.readlines():
					data = line.strip().split(',')

					self.credentials.append({
						'name': data[0],
						'host': data[1],
						'username': data[2],
						'password': data[3]
					})

		if credSourceType == 'url':
			response = requests.get(credSourcePath)

			for line in response.text.strip().split('\n'):
				data = line.split(',')

				self.credentials.append({
					'name': data[0],
					'host': data[1],
					'username': data[2],
					'password': data[3]
				})

	def createConnections(self):	

		threadPool = {}
		threadPos = 1		

		for cred in self.credentials:
			threadPool[threadPos] = threading.Thread(target=self.connect, args=(cred['name'], cred['host'], cred['username'], cred['password'],))
			threadPool[threadPos].daemon = True
			threadPool[threadPos].start()
			threadPos += 1
			
		for i in range(1, threadPos):
			threadPool[i].join()
			

	def connect(self, name, host, username, password):

		tries = 1
		maxTries = int(self.config.get('connection', 'max_retries'))
		delay = float(self.config.get('connection', 'delay'))

		while True:

			if tries == maxTries:
				self.printError("Unable to connect to: " + name)
				break

			try:
				self.connectionPool[name] = paramiko.SSHClient()
				self.connectionPool[name].set_missing_host_key_policy(paramiko.AutoAddPolicy()) 
				self.connectionPool[name].connect(host, username=username, password=password)

				connected = True
			except:
				self.printError("Failed to connect to: " + name + "... retrying (" + str(tries) + "/" + str(maxTries) + ")")
				connected = False
				tries += 1
				time.sleep(delay)

			if connected:
				self.printSuccess("Successfully connected to: " + name)
				break


	def closeConnections(self):

		threadPool = {}
		threadPos = 1	

		for name in self.connectionPool:	
			threadPool[threadPos] = threading.Thread(target=self.exit, args=(name,))
			threadPool[threadPos].daemon = True
			threadPool[threadPos].start()
			threadPos += 1
							
		for i in range(1, threadPos):
			threadPool[i].join()	

	def exit(self, name):
			
			try:
				self.connectionPool[name].exec_command('exit')
				self.connectionPool[name].close()
			except Exception, e:
				self.printError(str(e))

			self.printAction(name, "disconnected...")

	def listen(self):
		
		while True:

			cmd = raw_input('\nmaster-ssh$ ').strip()

			if cmd == "exit":
				self.closeConnections()
				break
			else:

				if cmd.startswith('master-ssh'):
					findSpace = cmd.find(' ')
					command = cmd[(findSpace + 1):len(cmd)].strip()
					server = cmd[11:findSpace].strip()
					
					if "," in server:

						threadPool = {}
						threadPos = 1

						for server in server.split(','):

							if server not in self.connectionPool:
								self.printError(server + " does not exist!")
							else:
								con = self.connectionPool[server]

								threadPool[threadPos] = threading.Thread(target=self.execute, args=(command, server, con,))
								threadPool[threadPos].daemon = True
								threadPool[threadPos].start()
								threadPos += 1
							
						for i in range(1, threadPos):
							threadPool[i].join()

					else:

						if server not in self.connectionPool:
							self.printError(server + " does not exist!")
						else:
							stdin, stdout, stderr = self.connectionPool[server].exec_command(command)

							error = ""

							for line in stderr:
								error += "\n" + line

							self.printServerError(server, error.strip())

							response = ""

							for line in stdout:
								response += line

							self.printAction(server, response.strip())


				else:
					threadPool = {}
					threadPos = 1	

					for name,con in self.connectionPool.iteritems():							

						threadPool[threadPos] = threading.Thread(target=self.execute, args=(cmd, name, con,))
						threadPool[threadPos].daemon = True
						threadPool[threadPos].start()
						threadPos += 1
							
					for i in range(1, threadPos):
						threadPool[i].join()
							
						

	def execute(self, cmd, name, con):
		stdin, stdout, stderr = con.exec_command(cmd)

		error = ""

		for line in stderr:
			error += "\n" + line

		self.printServerError(name, error.strip())

		response = ""

		for line in stdout:
			response += line

		self.printAction(name, response.strip())

	"""
	Helper methods
	"""

	def printAction(self, server, message):
		print '\033[92m\033[1m\033[4m[' + server + ' | Output]\033[0m: ' + message

	def printSuccess(self, message):
		print "\033[92m" + message + '\033[0m'

	def printError(self, message):

		if message != "":
			print 'master-ssh: \033[91m' + message + '\033[0m'

	def printServerError(self, server, message):

		if message != "":
			print '\033[92m\033[1m\033[4m[' + server + ' | Error]\033[0m: \033[91m' + message + '\033[0m'


m = MasterSSH()
m.createConnections()
m.listen()

print "SSH sessions ended, closing..."
sys.exit(0)
