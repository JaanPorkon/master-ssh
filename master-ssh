#!/usr/bin/env python

import paramiko
import requests
import argparse
import sys
import time
import threading
import ConfigParser
import os

class MasterSSH:

	connectionPool = {}
	selectedServers = []
	credentials = []
	config = None

	commandPool = []

	"""
	Initalize everything
	"""

	def __init__(self):

		# Load configuration
		self.parseConfig()

		# Set log's path:		
		self.initLogs()

		# Parse command line arguments
		self.parseCli()

		credSourceType = None
		credSourcePath = None

		# Validate that file exists and assign it as credentials source
		if self.args.cred_file != None:

			if os.path.isfile(self.args.cred_file): 
				credSourcePath = self.args.cred_file
				credSourceType = 'file'
			else:
				self.printError(self.args.cred_file + " does not exist!")
				sys.exit(1)
			
		# Assign URL as credentials source
		if self.args.cred_url != None:
			credSourcePath = self.args.cred_url
			credSourceType = 'url'

		# If there are specific servers selected, store their names
		if self.args.servers != None:
			self.selectedServers = self.args.servers.strip().split(',')

		# If credentials path has not been defined, show an error
		if credSourcePath == None and self.args.manual == False:
			self.printError("You need to specify a credentials getting method [--cred-url, --cred-file, --manual]")
			sys.exit(1)		

		# If credentials source is file, pull info from it
		if credSourceType == 'file':
			with open(credSourcePath, 'r') as f:
				for line in f.readlines():
					data = line.strip().split(',')

					self.credentials.append({
						'name': data[0],
						'host': data[1],
						'username': data[2],
						'password': data[3]
					})

		# If credentials source is an URL, download the data
		if credSourceType == 'url':
			
			try:
				request = requests.get(credSourcePath)
			except requests.ConnectionError:
				self.printError("Failed to download data! Please check your URL.")
				sys.exit(1)
			except requests.HTTPError:
				self.printError("Bad HTTP request!")
				sys.exit(1)
			except requests.Timeout:
				self.printError("Connection to your domain timed out, please check your server!")
				sys.exit(1)
			except requests.TooManyRedirects:
				self.printError("There are too many redirects for your URL, check your server configuration!")
				sys.exit(1)
			except Exception, e:
				self.printError("Something went wrong: " + str(e))
				sys.exit(1)

			response = request.text.strip()

			if request.status_code not in [200, 301, 302]:
				self.printError(credSourcePath + " did not respond correctly (" + request.status_code + ")!")
				sys.exit(1)

			if response == "":
				self.printError(credSourcePath + " does not contain any data!")
				sys.exit(1)

			for line in response.split('\n'):
				data = line.split(',')

				self.credentials.append({
					'name': data[0],
					'host': data[1],
					'username': data[2],
					'password': data[3]
				})

	"""
	Create connection threads
	"""
	def createConnections(self):	

		if self.credentials:
			self.printMessage("Connecting to servers...")

		threadPool = {}
		threadPos = 1	
		useSelectedServers = False	

		if len(self.selectedServers) > 0:
			useSelectedServers = True			

		for cred in self.credentials:

			# If there are specific servers user wants to use, use them ...
			if useSelectedServers:
				if cred['name'] in self.selectedServers:
					threadPool[threadPos] = threading.Thread(target=self.connect, args=(cred['name'], cred['host'], cred['username'], cred['password'],))
					threadPool[threadPos].daemon = True
					threadPool[threadPos].start()
					threadPos += 1

			# ... if not, use all of them
			else:
				threadPool[threadPos] = threading.Thread(target=self.connect, args=(cred['name'], cred['host'], cred['username'], cred['password'],))
				threadPool[threadPos].daemon = True
				threadPool[threadPos].start()
				threadPos += 1

			
		for i in range(1, threadPos):
			threadPool[i].join()

		self.printMessage("Welcome to master-ssh!")

	"""
	Connect to the server
	"""
	def connect(self, name, host, username, password):

		tries = 1
		maxTries = int(self.config.get('connection', 'max_retries'))
		delay = float(self.config.get('connection', 'delay'))

		while True:

			if tries == maxTries:
				self.printError("Unable to connect to: " + name)
				break

			try:
				self.connectionPool[name] = paramiko.SSHClient()
				self.connectionPool[name].set_missing_host_key_policy(paramiko.AutoAddPolicy()) 
				self.connectionPool[name].connect(host, username=username, password=password)

				connected = True
			except paramiko.ssh_exception.AuthenticationException:
				self.printError("Failed to connect to: " + name + " - Wrong login details!")
				break
			except paramiko.ssh_exception.BadAuthenticationType:
				self.printError("Failed to connect to: " + name + " - Bad authentication type!")
				break
			except:
				self.printError("Failed to connect to: " + name + "... retrying (" + str(tries) + "/" + str(maxTries) + ")")
				connected = False
				tries += 1
				time.sleep(delay)

			if connected:
				self.printSuccess("Successfully connected to: " + name)
				break

	"""
	Create connection closing threads
	"""
	def closeConnections(self):

		threadPool = {}
		threadPos = 1	

		for name in self.connectionPool:	
			threadPool[threadPos] = threading.Thread(target=self.exit, args=(name,))
			threadPool[threadPos].daemon = True
			threadPool[threadPos].start()
			threadPos += 1
							
		for i in range(1, threadPos):
			threadPool[i].join()

		self.printSuccess("Bye, bye!")	

	"""
	Close all open connections
	"""
	def exit(self, name):
			
			print "exiting"
			try:
				print "sending command"
				self.connectionPool[name].exec_command('exit', timeout=2)	
				print "Command sent!"			
			except Exception, e:
				print "printing error"
				self.printError(str(e))

			print "sending close"
			self.connectionPool[name].close()
			print "close sent"
			self.printAction(name, "disconnected...")

	"""
	Listen for user commands
	"""
	def listen(self):
		
		while True:

			# Listen for user input
			cmd = raw_input('master-ssh$ ').strip()

			if cmd == "exit":
				self.closeConnections()
				break
			else:

				# Check for internal commands
				if cmd.startswith('#'):

					"""
					INTERNAL COMMANDS
					"""

					if cmd == "#help" or cmd == "#":

						print "Welcome to master-ssh!"
						print "Made by Jaan Porkon <jaantrill[at]gmail.com>"
						print "https://github.com/JaanPorkon/master-ssh"
						print ""
						print "Example syntax:"
						print "#[command]"
						print ""
						print "Example command:"
						print "#help"
						print ""
						print "Below you can find available commands that you can use:"
						print ""
						print "help                                        - Displays this message"
						print "list-connections                            - Lists the state of all connections"
						print "disconnect:[hostname,hostname2,...]         - Disconnects a specific host and removes it from the pool"
						print "                                            - Example:"
						print "                                              #disconnect:host1"
						print "                                            - or multiple servers:"
						print "                                              #disconnect:host2,host3"
						print "ignore:[hostname,hostname2] [command]       - Ignores servers that are listed"
						print "connect:[host],[username],[password],[name] - Connects to a server. [name] is optional, but suggested"

					# List all connections
					elif cmd == "#list-connections":
						
						for name, con in self.connectionPool.iteritems():

							isAlive = con.get_transport().is_active()

							if isAlive:
								self.printAction(name, "connection active")
							else:
								self.printServerError(name, "is disconnected")

					elif cmd.startswith('#connect:'):
						data = cmd.replace('#connect:', '').split(':')

						# host:username:password:name*
						# * name is optional

						if len(data) == 3:
							self.connect(data[0], data[0], data[1], data[2])
						elif len(data) == 4:
							self.connect(data[3], data[0], data[1], data[2])
						else:
							self.printError("Not enough arguments!")

					# Disconnect specific servers from the pool
					elif cmd.startswith('#disconnect:'):

						servers = cmd.strip().split(':')[-1]

						for server in servers.split(','):
							if server in self.connectionPool:							
								connection = self.connectionPool[server]

								try:
									if connection.get_transport().is_active():
										connection.exec_command('exit')
										connection.close()
										self.connectionPool.pop(server)

										self.printSuccess(server + " successfully disconnected!")
									else:
										self.connectionPool.pop(server)
								except Exception, e:
									self.printError('Unable to disconnect: ' + server + ' (' + str(e) + ')')

							else:
								self.printError(server + " does not exist!")


						if len(self.connectionPool) == 0:
							self.printMessage("Connection pool is empty, closing the program..")
							sys.exit(0)

					else:

						"""
						SERVER COMMANDS
						"""

						useIgnoreList = False
						serverListStart = 1

						findSpace = cmd.find(' ')
						command = cmd[(findSpace + 1):len(cmd)].strip()

						# If user wishes to ignore specific servers, do so ...
						if cmd.startswith("#ignore:"):
							serverListStart = 8
							useIgnoreList = True

						server = cmd[serverListStart:findSpace].strip()

						if useIgnoreList:

							ignoreList = server.strip().split(',')

							threadPool = {}
							threadPos = 1	

							for name,con in self.connectionPool.iteritems():							

								if name not in ignoreList:
									threadPool[threadPos] = threading.Thread(target=self.execute, args=(command, name, con,))
									threadPool[threadPos].daemon = True
									threadPool[threadPos].start()
									threadPos += 1
									
							for i in range(1, threadPos):
								threadPool[i].join()

							ignoreList = []

						# ... if not, send the command to ...
						else:
						
							# ... specific servers that user has defined or ...
							if "," in server:

								threadPool = {}
								threadPos = 1

								for server in server.split(','):

									if server not in self.connectionPool:
										self.printError(server + " does not exist!")
									else:
										con = self.connectionPool[server]

										threadPool[threadPos] = threading.Thread(target=self.execute, args=(command, server, con,))
										threadPool[threadPos].daemon = True
										threadPool[threadPos].start()
										threadPos += 1
									
								for i in range(1, threadPos):
									threadPool[i].join()

							# ... send the command to one specific server
							else:

								if server not in self.connectionPool:
									self.printError(server + " does not exist!")
								else:
									stdin, stdout, stderr = self.connectionPool[server].exec_command(command)

									error = ""

									for line in stderr:
										error += "\n" + line

									self.printServerError(server, error.strip())

									response = ""

									for line in stdout:
										response += line

									self.printServerAction(server, response.strip())


				# If user haven't defined any internal comments, send user's command to all of the servers
				else:
					threadPool = {}
					threadPos = 1	

					for name,con in self.connectionPool.iteritems():							

						threadPool[threadPos] = threading.Thread(target=self.execute, args=(cmd, name, con,))
						threadPool[threadPos].daemon = True
						threadPool[threadPos].start()
						threadPos += 1
							
					for i in range(1, threadPos):
						threadPool[i].join()
							
	"""
	Execute user's command
	"""
	def execute(self, cmd, name, con):
		stdin, stdout, stderr = con.exec_command(cmd)

		error = ""

		for line in stderr:
			error += "\n" + line

		self.printServerError(name, error.strip())

		response = ""

		for line in stdout:
			response += line

		self.printServerAction(name, response.strip())

	"""
	Helper methods
	"""

	def printMessage(self, message):
		print message

	def printAction(self, server, message):
		print '\033[92m\033[1m\033[4m[' + server + ']\033[0m: ' + message

	def printServerAction(self, server, message):
		print '\033[92m\033[1m\033[4m[' + server + ']\033[0m:\n' + message

	def printSuccess(self, message):
		print "\033[92m" + message + '\033[0m'

	def printError(self, message):
		if message != "":
			print 'master-ssh: \033[91m' + message + '\033[0m'

	def printServerError(self, server, message):
		if message != "":
			print '\033[92m\033[1m\033[4m[' + server + ']\033[0m: \033[91m' + message + '\033[0m'

	def parseConfig(self):
		configPath = os.path.realpath("/usr/local/bin/master-ssh").split('/')
		configPath.pop()

		self.config = ConfigParser.ConfigParser()
		self.config.read("/".join(configPath) + "/" + "master-ssh.conf")

	def initLogs(self):
		logFile = self.config.get('log', 'paramiko')

		if not os.path.exists(logFile):
			os.makedirs(os.path.dirname(logFile))

		if not os.path.isfile(logFile):
			open(logFile, 'w')

		paramiko.util.log_to_file(logFile)

	def parseCli(self):
		parser = argparse.ArgumentParser()
		parser.add_argument('--cred-url', dest='cred_url', default=None, help='URL that points to credentials data')
		parser.add_argument('--cred-file', dest='cred_file', default=None, help='Path to your credentials file')
		parser.add_argument('--servers', dest='servers', default=None, help='A comma separated list of server hostnames')
		parser.add_argument('--manual', dest='manual', action='store_true', help='Use this when you wish to connect manually from the program')

		self.args = parser.parse_args()



m = MasterSSH()
m.createConnections()
m.listen()
sys.exit(0)